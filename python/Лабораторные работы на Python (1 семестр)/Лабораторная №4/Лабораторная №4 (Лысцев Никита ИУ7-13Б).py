# Лысцев Н. Д. ИУ7-13Б

# Построение графика функции звездочками

# Ввод
# x0 - начальное значение аргумента х
# xn - конечное значение аргумента х
# h - шаг разбиения отрезка, заданного значениями х0 и xn
# number_of_serifs - количество засечек

# Вывод
# таблица значений для двух функций
# график одной из функций звездочками
# sum_max - Сумма максимального значения функции z и функции y на заданном отрезке

# Импорт библиотеки Python math
import math as m

# Введение необходимых для построения таблицы и графика значений
x0, xn, h = map(float, input('Введите начальное, конечное значение аргумента '
                             'и шаг разбиения через пробел: ').split())
# Проверка входных данных
if x0 > xn:
    print('Неверный ввод! Начальное значение аргумента  должно быть меньше конечного.')
elif x0 < xn and h <= 0:
    print('Неверный ввод! Шаг разбиения не может быть отрицательным или равным нулю.')
elif x0 == xn:
    print('Неверный ввод! Начальное значение аргумента не должно равняться конечному.')
elif x0 < xn and h > (xn - x0):
    print('Неверный ввод! Шаг разбиения не должен превышать '
          'разность конечного и начального значения аргументов.')
else:
    # Вывод части таблицы с обозначениями функций
    print('----------------------------------------------------------------------------------')
    print('|            x             |            y             |            z             |')
    print('----------------------------------------------------------------------------------')

    x = x0
    max_y = float("-inf")
    min_y = float("inf")

    max_z = float("-inf")
    # Ограничение ширины печати графика в 80 символов
    chart_width = 80
    count_iter = int((xn - x0) / h) + 1
    for i in range(count_iter):

        # Вычисление значений функций на заданном отрезке
        if x > 0:
            z = x * m.sin(m.log(x) - (m.pi / 4))
            # Поиск максимального значения функции z на заданном отрезке
            if z > max_z:
                max_z = z
        y = (x / 2) * m.sqrt(x ** 2 + 1) - m.log(x + m.sqrt(x ** 2 + 1))
        # Поиск максимального и минимального значения функции у на заданном отрезке
        if y > max_y:
            max_y = y
        if y < min_y:
            min_y = y
        # Поиск максимального значения функции z на заданном отрезке

        # Приведение очень больших  и очень маленьких значений функции к экспоненциальной записи

        if y >= 100 or y <= -100:
            y = '{:10.4g}'.format(y)
        elif 0 < x < 1:
            y = '{:10.4g}'.format(y)
        else:
            y = '{:10.5g}'.format(y)

        if x <= 0:
            z = '    -     '
        elif z >= 100 or z <= -100:
            z = '{:10.4g}'.format(z)
        elif 0 < x < 1:
            z = '{:10.4g}'.format(z)
        else:
            z = '{:10.5g}'.format(z)

        if x >= 100 or x <= -100:
            b = '{:10.4g}'.format(x)
        elif 0 < x < 1:
            b = '{:10.4g}'.format(x)
        else:
            b = '{:10.5g}'.format(x)
        # Вывод агрумента х, а также значение функции у и значение функции z при этом аргументе
        print('|        {}        |        {}        |        {}        |'.format(b, y, z))
        x = x0 + (i + 1) * h
        x = round(x, 8)
    print('----------------------------------------------------------------------------------')
    # Введение количества засечек
    number_of_serifs = int(input('Введите количество засечек (целое число от 4 до 8): '))
    # Проверка корректности введенных данный о количестве засечек
    if (number_of_serifs < 4) or (number_of_serifs > 8):
        print('Неверный ввод! Число засечек ограничено целыми числами от 4 до 8.')
    else:

        # масштаб
        scale = (max_y - min_y) / chart_width
        # расстояние от первой цифры одной засечки до первой цифры другой засечки в символах
        delta = chart_width / (number_of_serifs - 1)
        # значение, через которое проставляются засечки
        step = (max_y - min_y) / (number_of_serifs - 1)

        # Выведение оси ординат
        ordinate = '             '

        new_y = round(min_y, 5)
        new_y1 = min_y
        if new_y >= 100 or new_y <= -100:
            for i in range(number_of_serifs):
                str_new_y = '{:<10.4g}'.format(new_y)
                ordinate = ordinate + str_new_y + ' ' * int((delta - len(str_new_y)))
                new_y1 += step
                new_y = round(new_y1, 5)
        else:
            for i in range(number_of_serifs):
                str_new_y = str(new_y)
                ordinate = ordinate + str_new_y + ' ' * int((delta - len(str_new_y)))
                new_y1 += step
                new_y = round(new_y1, 5)

        print(ordinate)

        new_x = x0
        count_iter = int((xn - x0) / h) + 1
        for j in range(count_iter):
            # Приведение очень больших  и очень маленьких значений функции к экспоненциальной записи
            if new_x >= 100 or new_x <= -100:
                abscissa = '|{:^10.4g}| '.format(new_x)
            elif 0 < new_x < 1:
                abscissa = '|{:^10.4g}| '.format(new_x)
            else:
                abscissa = '|{:^10.5g}| '.format(new_x)

            # Вычисление функции, график которой будет построен
            y = (new_x / 2) * m.sqrt(new_x ** 2 + 1) - m.log(new_x + m.sqrt(new_x ** 2 + 1))

            # целое число, расстояние от текущего значения функции у до минимального в символах
            # расстояние, на котором будут стоять звездочки, чтобы получился график
            distance = int(abs(y - min_y) / scale)

            # Пустая строка на 79 символов, которая будет заполнена символом * на нужном расстоянии
            function_graph = ' ' * (chart_width - 1)
            # Заполнение строки
            function_graph = function_graph[:distance] + '*' + function_graph[distance + 1:]

            # целое число, расстояние от значения функции у = 0 до минимального в символах
            intersection = int(abs(0 - min_y) / scale)

            # Если условие выполняется, то график пересекает ось х
            if min_y <= 0 and max_y >= 0:
                # Если точка пересечения графика с осью х совпала с точкой для отображения символа *,
                # то выводим вместо звездочки крестик, показывающий пересечение
                if function_graph[intersection] == '*':
                    function_graph = function_graph[:intersection] + 'x' + function_graph[intersection + 1:]
                # Иначе - выводим саму ось х
                else:
                    function_graph = function_graph[:intersection] + '|' + function_graph[intersection + 1:]

            # складываем строку со значением аргумента и строку с символом *
            abscissa += function_graph
            # Вывод этой строки
            print(abscissa)
            new_x = x0 + (j + 1) * h
            new_x = round(new_x, 8)

    # Вычисление суммы максимального значения функции z и функции y на заданном отрезке
    sum_max = max_z + max_y
    # Вывод получившейся суммы
    print('Сумма максимального значения функции z '
          'и функции y на заданном отрезке равна: {:.5}'.format(sum_max))
